+++
title = "Сбор и агрегирование метрик. Часть 1"
date = "2016-12-16T12:00:42+02:00"
+++

Недавно я читал доклад на golang митапе в Киеве о метриках и логах для программистов и остался собой недоволен, так как у меня не получилось высказать всё, что хотел, коротко и ёмко. Поэтому я решил написать пару статей о том, что такое метрики и statsd, и коротко рассказать о том, как и чем можно собирать метрики и какие архитектуры использовать. 

# Что такое statsd

Чтобы понять, что такое statsd и какие проблемы он решает, стоит понять, что такое метрика. 

Метрика — это сгруппированные по ключу данные в формате значение - время. 

Такой формат данных позволяет достаточно эффективно привязывать какие-либо события ко времени и впоследствии делать выборки или рисовать графики. 

Обычно метрики складывают в разные специальные TSDB (time series database): 

* _whisper_ — graphite, go-carbon
* _rrd_ — rrd-tool
*  _TSMT_ — influxdb

Или в другие бд: 

* _cassandra_ — M3, newTS, cyanite, kairosDB
*  _hbase_ — openTSDB
*  _LevelDB_ — prometheus

Метрика может представлять собой как срезы по времени (например, сколько соединений в конкретный момент времени были в состоянии _ESTABLISHED_), так и различные агрегации (сколько подключений было всего за период в 10 секунд)

Сами по себе агрегации тоже бывают разными. Например, популярная метрика LA является агрегацией других метрик (вот [тут](https://habrahabr.ru/post/260335/) есть хороший разбор) и дополнительно агрегирована по периоду времени в одну, пять и пятнадцать минут. Таким образом, просто делая срезы LA раз в десять секунд, мы сможем примерно представлять динамику изменений этого параметра. 

Другие метрики, такие как скорость сети, измеряются при помощи считывания счетчиков, которые уже есть в linux. 
В случае пропускной способности сети мы можем посмотреть `/sys/class/net/eth0/statistics/rx_bytes` или `/proc/net/dev`. Значение, которое мы увидим, — некий счетчик, который увеличивается с каждый принятым байтом с начала отсчёта. 

![](_________________.png)
Подобный график очень сложно интерпретировать, но так как мы делаем срез через определённые интервалы, просто отнимем от левого значения правое и получим количество байтов, которые пришли за этот интервал. 

![](_________________%202.png)

Для удобства, чтобы оперировать привычными юнитами, можно ещё повыполнять различные арифметические операции деления и прийти к обычным kb\\s.

Первый существенный минус такого подхода в том, что каждый раз, когда перезапускается счетчик, мы получаем большое отклонение. 
![](_________________%203.png)
Чтобы его убрать, можно использовать специальную функцию [nonNegativeDerivative](http://graphite.readthedocs.io/en/latest/functions.html#graphite.render.functions.nonNegativeDerivative) в графите, которая убирает все отрицательные значения. 
Второй минус в том, что каждый раз при просмотре графика мы производим вычисления, без которых можно обойтись. 

Логичным выходом из такой ситуации станет счетчик, который будет обнуляться в начале каждого интервала. 

Но не счетчиками едиными: иногда надо посмотреть на распределение значения по времени. Особенно это актуально, если мы замеряем какое-то время. 
![](_________________%204.png)
Тут всё сложнее, так как невозможно сделать постагрегацию, если не хранить вообще все значения. Про гистограммы на примере мониторинга http я писал более-менее подробно [тут](https://ctrlok.com/post/web-server-percentiles/). 

И последний вид необратимых агрегаций — уники. Например, если вам надо посчитать, сколько уникальных юзеров получили 500 за 10 секунд. 
![](_________________%205.png)

В принципе, этими тремя типами агрегаций можно охватить все известные мне счетчики. Если вы знаете что-то, что нельзя покрыть каунтерами, сетами и гистограммами, обязательно напишите мне в комментариях, я буду очень признателен. 

# statsd — зачен он нужен?

После того как мы выяснили, как именно можно предагрегировать метрики, можно реализовать это всё у себя в коде. Уже есть множество разных библиотек под многие из языков программирования, самая популярная — это вариация [metrics](http://metrics.dropwizard.io/3.1.0/), портированная на разные языки. 

Или просто использовать демон, который делает это всё за вас. У обоих вариантов есть свои плюсы и минусы, и об этом мы поговорим в следующей статье. 
